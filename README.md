[Ссылка на схему БД](https://app.quickdatabasediagrams.com/#/d/P3E3M5)

![data base diagram](src/main/images/Data Base Diagram.png)
### [ссылка на класс FilmController](src/main/java/ru/yandex/practicum/filmorate/controller/FilmController.java)
### **Примеры SQL запросов для основных операций приложения в классе FilmController:**
### **Создание таблиц**
```PostgreSQL
CREATE TABLE films (
        film_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar NOT NULL AND CHECK (name != '') AND UNIQUE (name),
        description varchar(200),
        release_date date NOT NULL,
        duration int NOT NULL AND CHECK (duration > 0),
        rating_MPA_id DEFAULT 'unknown'
);

CREATE TABLE rating_MPA (
        rating_MPA_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar NOT NULL AND CHECK (name != '') AND UNIQUE (name)
);

ALTER TABLE films ADD CONSTRAINT fk_films_rating_MPA_id
    FOREIGN KEY(rating_MPA_id) REFERENCES rating_MPA (rating_MPA_id) ON DELETE CASCADE;

CREATE TABLE film_genre (
        film_id INTEGER PRIMARY KEY DEFAULT 0,
        genre_id INTEGER PRIMARY KEY DEFAULT 0
);

CREATE TABLE genre (
        genre_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar NOT NULL AND CHECK (name != '') AND UNIQUE (name)
);

ALTER TABLE film_genre ADD CONSTRAINT fk_film_genre_film_id
    FOREIGN KEY(film_id) REFERENCES films (film_id) ON DELETE CASCADE;

ALTER TABLE film_genre ADD CONSTRAINT fk_film_genre_genre_id
    FOREIGN KEY(genre_id) REFERENCES genre (genre_id) ON DELETE CASCADE;

CREATE TABLE film_likes (
        film_id INTEGER PRIMARY KEY DEFAULT 0,
        user_id INTEGER PRIMARY KEY DEFAULT 0
);
```
### **@PostMapping("/films")**
```PostgreSQL
INSERT INTO films (name, description, release_date, duration)
VALUES ('film.name', 'film.description', 'film.release_date', film.duration);

INSERT INTO rating_MPA (name)
VALUES ('G'),
        ('PG'),
        ('PG-13'),
        ('R'),
        ('NC-17');

INSERT INTO rating_MPA (name)
VALUES ('film.rating_MPA')
ON CONFLICT (name) DO NOTHING;

INSERT INTO films (rating_MPA_id)
SELECT rm.rating_MPA_id
FROM rating_MPA AS rm
WHERE rating_MPA.name = 'film.ratingMPA';

INSERT INTO genre (name)
VALUES ('Комедия'),
        ('Драма'),
        ('Мультфильм'),
        ('Триллер'),
        ('Документальный'),
        ('Боевик');
        
INSERT INTO genre (name)
VALUES ('film.genre')
ON CONFLICT (name) DO NOTHING;

INSERT INTO film_genre (film_id)
SELECT f.film_id
FROM films AS f
WHERE films.name = 'film.name';

UPDATE films_genre as fg
SET fg.genre_id =
    (SELECT g.genre_id 
    FROM genre AS g
    WHEN g.name = 'film.genre')
WHERE films_genre.film_id = film.id;

INSERT INTO film_likes (film_id)
SELECT f.film_id
FROM films AS f
WHERE films.name = 'film.name';
```
### **@GetMapping("/films")**
```PostgreSQL
SELECT f.name,
        f.description,
        f.release_date,
        f.duration,
        g.name,
        rm.name,
        fl.user_id
FROM films AS f
LEFT INNER JOIN film_genre AS fg ON f.film_id=fg.film_id
LEFT INNER JOIN genre AS g ON fg.genre_id=g.genre_id
LEFT INNER JOIN rating_MPA AS rm ON f.rating_MPA_id=r.rating_MPA_id
LEFT INNER JOIN film_likes AS fl ON f.film_id=fl.film_id;
```
### **@GetMapping("/films/{filmId}")**
```PostgreSQL
SELECT f.name,
        f.description,
        f.release_date,
        f.duration,
        g.name,
        rm.name,
        fl.user_id
FROM films AS f
LEFT INNER JOIN film_genre AS fg ON f.film_id=fg.film_id
LEFT INNER JOIN genre AS g ON fg.genre_id=g.genre_id
LEFT INNER JOIN rating_MPA AS rm ON f.rating_MPA_id=r.rating_MPA_id
LEFT INNER JOIN film_likes AS fl ON f.film_id=fl.film_id
WHERE films.film_id = filmId;
```
### **@GetMapping("/films/popular?count={countFilms}")**
```PostgreSQL
SELECT f.name,
        f.description,
        f.release_date,
        f.duration,
        g.name,
        rm.name,
        fl.user_id
FROM films AS f
LEFT INNER JOIN film_genre AS fg ON f.film_id=fg.film_id
LEFT INNER JOIN genre AS g ON fg.genre_id=g.genre_id
LEFT INNER JOIN rating_MPA AS rm ON f.rating_MPA_id=r.rating_MPA_id
LEFT INNER JOIN film_likes AS fl ON f.film_id=fl.film_id
GROUP BY f.name
ORDER BY COUNT(fl.user_id) DESC
LIMIT countFilms;
```
### **@PutMapping("/films")**
```PostgreSQL
UPDATE films
SET name = film.name,
    description = film.description,
    release_date = film.release_date,
    duration = film.duration
WHEN film_id = film.id;

UPDATE films as f
SET f.rating_MPA_id =
    (SELECT rating_MPA_id 
    FROM rating_MPA AS rm
    WHEN rm.name = 'film.ratingMPA')
WHERE films.film_id = film.id;

UPDATE films_genre as fg
SET fg.genre_id =
    (SELECT g.genre_id 
    FROM genre AS g
    WHEN g.name = 'film.genre')
WHERE films_genre.film_id = film.id;

DELETE
FROM films_likes 
WHERE film_id = film.id;

INSERT INTO film_likes (film_id, user_id)
VALUES ('film.id', 'film.friends[i]');
```
### **@PutMapping("/films/{filmId}/like/{userId}")**
```PostgreSQL
INSERT INTO film_likes (film_id, user_id)
VALUES (filmId, userId)
ON CONFLICT (film_id, user_id) DO NOTHING;
```
### **@DeleteMapping("/films/{filmId}/like/{userId}")**
```PostgreSQL
DELETE FROM film_likes
WHERE film_id = filmId AND user_id = userId;
```
### **Примеры SQL запросов для основных операций приложения в классе UserController:**
### [ссылка на класс UserController](src/main/java/ru/yandex/practicum/filmorate/controller/UserController.java)
### **Создание таблиц**
```PostgreSQL
CREATE TABLE users (
        user_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        login varchar NOT NULL AND CHECK (login != '') AND UNIQUE (login),
        name varchar CHECK (name != ''),
        email varchar NOT NULL AND CHECK (email LIKE '%@%.%'),
        birthday date NOT NULL AND CHECK (birthday < CURRENT_DATE),
        add_friend_status_id
);

ALTER TABLE film_likes ADD CONSTRAINT fk_film_likes_user_id
    FOREIGN KEY(user_id) REFERENCES users (user_id);
    
CREATE TABLE add_friend_status (
        add_friend_status_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name varchar CHECK (name != '')
);       

ALTER TABLE users ADD CONSTRAINT fk_users_add_friend_status_id
    FOREIGN KEY(uadd_friend_status_id) REFERENCES add_friend_status (add_friend_status_id) ON DELETE CASCADE;

CREATE TABLE user_friends (
        user_id PRIMARY KEY DEFAULT 0,
        user_friends_id PRIMARY KEY DEFAULT 0
);
 
ALTER TABLE user_friends ADD CONSTRAINT fk_user_friends_user_id
    FOREIGN KEY(user_id) REFERENCES users (user_id);

ALTER TABLE user_friends ADD CONSTRAINT fk_user_friends_user_friends_id
    FOREIGN KEY(user_friends_id) REFERENCES users (user_id);
```
### **@PostMapping("/users")**
```PostgreSQL
INSERT INTO users (login, name, email, birthday)
VALUES ('user.login', 'user.name', 'user.email', user.birthday);

INSERT INTO user_friends (user_id)
SELECT u.user_id
FROM users AS u
WHERE users.login = 'user.login';

UPDATE user_friends
SET user_friends_id = user.friends[i],
WHEN user_id = (SELECT u.user_id
                FROM users AS u
                WHERE u.login = 'user.login');

INSERT INTO add_friend_status (name)
VALUES ('Неподтверждённая'),
        ('Подтверждённая');
        
INSERT INTO add_friend_status (name)
VALUES (user.friend_status)
ON CONFLICT (name) DO NOTHING;

INSERT INTO users (add_friend_status_id)
SELECT afs.add_friend_status_id
FROM add_friend_status AS afs
WHERE add_friend_status.name = 'user.friendStatus';
```
### **@GetMapping("/users")**
```PostgreSQL
SELECT u.login,
        u.name,
        u.email,
        u.birthday,
        uf.user_friends_id,
        afs.name
FROM users AS u
LEFT INNER JOIN user_friends AS uf ON u.user_id=uf.user_id
LEFT INNER JOIN add_friend_status AS afs ON u.add_friend_status_id=afs.add_friend_status_id
```
### **@GetMapping("/users/{userId}")**
```PostgreSQL
SELECT u.login,
        u.name,
        u.email,
        u.birthday,
        uf.user_friends_id,
        afs.name
FROM users AS u
LEFT INNER JOIN user_friends AS uf ON u.user_id=uf.user_id
LEFT INNER JOIN add_friend_status AS afs ON u.add_friend_status_id=afs.add_friend_status_id
WHERE users.user_id = userId;
```
### **@GetMapping("/users/{userId}/friends")**
```PostgreSQL
SELECT u2.user_id,
        u2.login,
        u2.name,
        u2.email,
        u2.birthday,
        afs.name 
FROM user_friends AS uf
LEFT INNER JOIN users AS u2 ON uf.user_id=u2.user_id
LEFT INNER JOIN add_friend_status AS afs ON u2.add_friend_status_id=afs.add_friend_status_id
WHERE user_friends.user_id = userId;
```
### **@GetMapping("/users/{userId}/friends/common/{otherUserId}")**
```PostgreSQL
SELECT u2.user_id,
        u2.login,
        u2.name,
        u2.email,
        u2.birthday,
        afs.name 
FROM user_friends AS uf
LEFT INNER JOIN users AS u2 ON uf.user_id=u2.user_id
LEFT INNER JOIN add_friend_status AS afs ON u2.add_friend_status_id=afs.add_friend_status_id
WHERE user_friends.user_id = userId
  AND u2_user_id IN
    (SELECT u2.user_id,
        FROM user_friends AS uf
        LEFT INNER JOIN users AS u2 ON uf.user_id=u2.user_id
        LEFT INNER JOIN add_friend_status AS afs ON u2.add_friend_status_id=afs.add_friend_status_id
        WHERE user_friends.user_id = otherUserId) AS friends_other_user;
```
### **@PutMapping("/users")**
```PostgreSQL
UPDATE users
SET login = user.login,
    name = user.name,
    email = user.email,
    birthday = user.birthday,
WHEN user_id = user.id;

UPDATE user_friends
SET user_friends_id = user.friends[i]
WHEN user_id = user.id;

UPDATE users AS u
SET u.add_friend_status_id =
    (SELECT add_friend_status_id 
    FROM add_friend_status AS afs
    WHEN afs.name = 'film.friendStatus')
WHERE users.user_id = user.id;
```
### **@PutMapping("/users/{userId}/friends/{friendId}")**
```PostgreSQL
INSERT INTO user_friends (user_id, user_friends_id)
VALUE (userId, friendId)
ON CONFLICT (user_id, user_friends_id) DO NOTHING;
```
### **@DeleteMapping("/users/{userId}/friends/{friendId}")**
```PostgreSQL
DELETE FROM user_friends
WHERE user_id = userId AND user_friends_id = friendId;
```